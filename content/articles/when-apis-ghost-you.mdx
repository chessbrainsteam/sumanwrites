---
title: "ğŸ‘» When APIs Ghost You"
summary: "Weâ€™ve all had that one friend. You text them: > â€œHey, wanna grab lunch?â€ Andâ€¦ nothing. No reply. No read receipt. Just the digital void."
date: "2025-10-29"
featured: true
tags: []
cover: "/images/api-timeout.png"
category: "Engineering"

---

Weâ€™ve all had that one friend.

You text them:

> â€œHey, wanna grab lunch?â€

Andâ€¦ nothing.
No reply. No read receipt. Just the digital void.

So you wait.
You wonder.
Then you text again:

> â€œMaybe you didnâ€™t see this?â€

Welcome to the world of **API timeouts and retries** â€” where your app is *emotionally dependent* on another system that might not call back.

### ğŸ§  What Is an API Timeout?

An API timeout is your app saying:

> â€œI asked you for something, but you took too long, so Iâ€™m leaving.â€

Maybe the other service is:

- Busy
- Broken
- Sleeping
- Being held hostage by a misconfigured load balancer

Either way, youâ€™re stuck waiting.

And in tech â€” just like in dating â€” **waiting too long with no response is never a good sign**.

### ğŸ” So What Do We Do? We Retry.

Your app says:

> â€œHey, just checking in again in case you missed this!â€

Retries are your codeâ€™s version of:

- â€œğŸ‘‹ just bumping this to the top of your inboxâ€
- â€œHey, sorry, meant to follow up on this thread!â€

They work â€” sometimes.

### âŒ But Wait â€” When Shouldnâ€™t You Retry?

Not all failures deserve a second chance.

Hereâ€™s the golden rule:

> Only retry if the request was **safe to repeat**.

### âœ… Retry these:

- Network timeout
- 502 Bad Gateway
- 503 Service Unavailable

### âŒ Donâ€™t retry these:

- 400 Bad Request (you messed up)
- 401 Unauthorized (you really messed up)
- 500 Internal Server Error? Depends (could be your bad or theirs)

And for the love of servers, **donâ€™t retry POSTs blindly** unless theyâ€™re idempotent.
Otherwise, you just paid someone *twice* or created two users named â€œHelp.â€

### â³ How Long Should You Wait?

Thatâ€™s where **exponential backoff** comes in.

Itâ€™s like saying:

> â€œOkay, Iâ€™ll try again in 1 second.Still no answer? Iâ€™ll wait 2 secondsâ€¦ then 4â€¦ then 8â€¦â€

The goal is:

- Stop hammering the server
- Still give it a chance to recover
- Not completely ghost it forever

Some systems add **jitter** â€” random delays â€” so a thousand apps donâ€™t retry at the exact same time.
Because then you get a **Distributed DoS Attack... on yourself.**

### ğŸ’¬ Real-Life Analogy

Letâ€™s say your app asks for order status:

```
GET /order/123/status
```

And the service is slow. You:

- Retry 3 times
- Wait longer between tries
- Thenâ€¦ give up (timeout)
- Show user:

> â€œSorry, weâ€™re having trouble retrieving your order. Please try again later.â€

ğŸ¯ Thatâ€™s respectful ghosting.
Not ideal, but better than freezing.

### ğŸ” Bonus: Idempotency Keys

For APIs that do *stuff* (like POST /payments), you need **idempotency keys**.

Theyâ€™re like:

> â€œIf I accidentally send this request twice, treat it as one, please.â€

You attach a unique token:

```
POST /purchase Idempotency-Key: x123abc
```

The server says:

> â€œGot it â€” if I see this again, I wonâ€™t process it twice.â€

### ğŸ§  Final Thought

APIs ghost you. It happens.

But your job isnâ€™t just to **call** another service â€” itâ€™s to handle the silence with grace.

> Retry â€” but politely.Back off â€” but not forever.And always have a message ready for the user that isnâ€™t just... "ğŸ¤·â€â™‚ï¸ Unknown error."

Because the app that *handles failure well* is the one users keep trusting â€” even when the server ghosts you.
