---
title: "ğŸ›¡ï¸Cross-Site Request Forgery (CSRF)"
summary: "Imagine this: Youâ€™re logged into your bank account. You open a new tab, read a blog, click a cat videoâ€¦ and without knowing it, you just *transferred $1,000..."
date: "2025-10-29"
featured: false
tags: []
cover: "/images/CSRF.png"
category: "Engineering"
---

Imagine this:

Youâ€™re logged into your bank account. You open a new tab, read a blog, click a cat videoâ€¦ and without knowing it, you just *transferred $1,000 to someone else*. ğŸ˜³

Thatâ€™s **Cross-Site Request Forgery**, or **CSRF**.
A fancy name for a sneaky problem.

Letâ€™s break it down like youâ€™re five.

### ğŸ’£ What Is CSRF?

Itâ€™s when a **bad website tricks your browser into doing something on a site youâ€™re already logged into**.

Itâ€™s like someone handing you a form and saying,

> â€œCan you just sign this real quick?â€And it turns out, you just gave away your house.

### ğŸ§  How Does It Work?

Hereâ€™s the basic recipe:

1. Youâ€™re logged into your bank or favorite app in one tab.
2. You visit a shady site in another tab.
3. That shady site secretly makes a request (like "Transfer money") **as you**, because your browser still holds your session cookies.
4. The bank sees the request, checks your cookies, thinks *you* sent it â€” and goes ahead.

Oops.

### ğŸ¤” Why Is This Possible?

Because browsers **automatically attach your cookies** (including login sessions) with every request â€” even if the request is from another website.

CSRF takes advantage of that loyalty.
The browser doesnâ€™t ask:

> â€œDid the user *really* mean to do this?â€

### ğŸ” Soâ€¦ How Do We Fix It?

Letâ€™s flip the table.

#### âœ… 1. CSRF Tokens (a secret handshake)

Every time your app shows a form (like â€œUpdate Profileâ€ or â€œMake Paymentâ€), it includes a **hidden secret token** â€” unique to your session.

When the form is submitted, the server checks:

- â€œIs this a valid session?â€
- â€œIs the token included?â€
- â€œDoes it match?â€

If someone tries to trick the user into submitting the form, they **wonâ€™t have the token**.
Boom â€” request blocked.

#### âœ… 2. SameSite Cookies

Modern browsers let you flag your cookies with:

```
Set-Cookie: sessionId=abc123; SameSite=Strict
```

This tells the browser:

> â€œOnly send this cookie if the request came directly from my site.â€

So even if a bad site tries to forge a request, the browser leaves the cookies behind.
**No cookie, no access.**

#### âœ… 3. Use POST, Not GET for Actions

Donâ€™t let users delete accounts or transfer money via a simple URL (e.g., `/delete?id=123`).
Use **POST or PUT**, and validate the request body.

### ğŸ§ª Example Time

Without CSRF protection:

```
<form action="https://yourbank.com/transfer" method="POST">
<input type="hidden" name="amount" value="1000"> 
<input type="hidden" name="toAccount" value="attacker123"> 
<input type="submit" value="Click me for a prize!"> </form>
```

The user thinks theyâ€™re clicking a prize â€” but they just sent money.

With CSRF token:

```
<input type="hidden" name="csrf_token" value="random123xyz">
```

The attacker doesnâ€™t have the token.
The bank rejects the request.

### ğŸ§  Final Thought

CSRF isnâ€™t about stealing data â€” itâ€™s about **abusing your authority**.

> Your browser trusts you.CSRF tricks it into doing things **you didnâ€™t mean to do**.

The fix isnâ€™t complicated:

- Use CSRF tokens for state-changing requests.
- Set your cookies with SameSite=Strict or Lax.
- Donâ€™t let sensitive actions happen through GET URLs.
